import * as basic from "./compiler";
import { SourceLocation } from "../workertypes";
export interface InputResponse {
    line: string;
    vals: string[];
    elapsed?: number;
}
declare class ExprOptions {
    isconst?: boolean;
    novalid?: boolean;
    locals?: string[];
}
interface CompiledStatement {
    $run?: () => void;
}
declare class RNG {
    next: () => number;
    seed: (aa: any, bb: any, cc: any, dd: any) => void;
    seedfloat: (n: any) => void;
    randomize(): void;
    constructor();
}
export declare class BASICRuntime {
    program: basic.BASICProgram;
    allstmts: basic.Statement[];
    pc2label: Map<number, string>;
    label2pc: {
        [label: string]: number;
    };
    label2dataptr: {
        [label: string]: number;
    };
    datums: basic.Literal[];
    builtins: {};
    opts: basic.BASICOptions;
    margin: number;
    curpc: number;
    dataptr: number;
    vars: {
        [name: string]: any;
    };
    globals: {
        [name: string]: any;
    };
    arrays: {};
    defs: {};
    subroutines: {};
    forLoops: {
        [varname: string]: {
            $next: (name: string) => void;
        };
    };
    forLoopStack: string[];
    whileLoops: number[];
    returnStack: number[];
    column: number;
    rng: RNG;
    running: boolean;
    exited: boolean;
    trace: boolean;
    load(program: basic.BASICProgram): boolean;
    reset(): void;
    clearVars(): void;
    saveState(): {} & this;
    loadState(state: any): void;
    getBuiltinFunctions(): {};
    supportsFunction(fnname: string): boolean;
    runtimeError(msg: string): void;
    dialectError(what: string): void;
    getLineForPC(pc: number): number;
    getLabelForPC(pc: number): string;
    getCurrentSourceLocation(): SourceLocation;
    getCurrentLabel(): string;
    getStatement(): basic.Statement;
    step(): boolean;
    compileStatement(stmt: basic.Statement & CompiledStatement): void;
    compileJS(functext: string): () => void;
    executeStatement(stmt: basic.Statement & CompiledStatement): void;
    skipToEOL(): void;
    skipToElse(): void;
    skipToEOF(): void;
    skipToAfterNext(forname: string): void;
    skipToAfterWend(): void;
    gotoLabel(label: any): void;
    newLocalScope(): void;
    popLocalScope(): void;
    gosubLabel(label: any): void;
    returnFromGosub(): void;
    popReturnStack(): void;
    valueToString(obj: basic.Value, padding: boolean): string;
    float2str(arg: number, numlen: number): string;
    printExpr(obj: any): void;
    print(str: string): void;
    input(prompt: string, nargs: number): Promise<InputResponse>;
    resume(): void;
    expr2js(expr: basic.Expr, opts?: ExprOptions): string;
    assign2js(expr: basic.IndOp, opts?: ExprOptions): string;
    array2js(expr: basic.IndOp, opts?: ExprOptions): string;
    checkFuncArgs(expr: basic.IndOp, fn: Function): void;
    startForLoop(forname: string, init: number, targ: number, step?: number, endpc?: number): void;
    nextForLoop(name: any): void;
    whileLoop(cond: any): void;
    nextWhileLoop(): void;
    assign(name: string, right: number | string, isRead?: boolean): number | string;
    convert(name: string, right: number | string): number | string;
    convertToString(right: number | string, name?: string): string;
    convertToNumber(right: number | string, name?: string): number;
    dimArray(name: string, ...dims: number[]): void;
    getTotalArrayLength(dims: number[]): number;
    getArray(name: string, order: number): [];
    arrayGet(name: string, ...indices: number[]): basic.Value;
    modifyStringSlice(orig: string, add: string, start: number, end: number): string;
    getStringSlice(s: string, start: number, end: number): string;
    checkOnGoto(value: number, labels: string[]): number;
    onGotoLabel(value: number, ...labels: string[]): void;
    onGosubLabel(value: number, ...labels: string[]): void;
    nextDatum(): basic.Value;
    do__PRINT(stmt: basic.PRINT_Statement): string;
    preInput(): void;
    postInput(valid: boolean): void;
    do__INPUT(stmt: basic.INPUT_Statement): string;
    do__LET(stmt: basic.LET_Statement): string;
    do__FOR(stmt: basic.FOR_Statement): string;
    do__NEXT(stmt: basic.NEXT_Statement): string;
    do__IF(stmt: basic.IF_Statement): string;
    do__ELSE(stmt: basic.ELSE_Statement): string;
    do__WHILE(stmt: basic.WHILE_Statement): string;
    do__WEND(stmt: basic.WEND_Statement): string;
    do__DEF(stmt: basic.DEF_Statement): string;
    _DIM(dim: basic.IndOp): string;
    do__DIM(stmt: basic.DIM_Statement): string;
    do__GOTO(stmt: basic.GOTO_Statement): string;
    do__GOSUB(stmt: basic.GOSUB_Statement): string;
    do__RETURN(stmt: basic.RETURN_Statement): string;
    do__ONGOTO(stmt: basic.ONGO_Statement): string;
    do__ONGOSUB(stmt: basic.ONGO_Statement): string;
    do__DATA(): void;
    do__READ(stmt: basic.READ_Statement): string;
    do__RESTORE(stmt: basic.RESTORE_Statement): string;
    do__END(): string;
    do__STOP(): string;
    do__OPTION(stmt: basic.OPTION_Statement): void;
    do__POP(): string;
    do__GET(stmt: basic.GET_Statement): string;
    do__CLEAR(): string;
    do__RANDOMIZE(): string;
    do__CHANGE(stmt: basic.CHANGE_Statement): string;
    do__CONVERT(stmt: basic.CONVERT_Statement): string;
    do__SUB(stmt: basic.SUB_Statement): string;
    do__CALL(stmt: basic.CALL_Statement): string;
    isValid(obj: number | string): boolean;
    checkValue(obj: number | string, exprname: string): number | string;
    getDef(exprname: string): any;
    checkNum(n: number): number;
    checkString(s: string): string;
    add(a: any, b: any): number | string;
    sub(a: number, b: number): number;
    mul(a: number, b: number): number;
    div(a: number, b: number): number;
    idiv(a: number, b: number): number;
    mod(a: number, b: number): number;
    pow(a: number, b: number): number;
    band(a: number, b: number): number;
    bor(a: number, b: number): number;
    bnot(a: number): number;
    bxor(a: number, b: number): number;
    bimp(a: number, b: number): number;
    beqv(a: number, b: number): number;
    land(a: number, b: number): number;
    lor(a: number, b: number): number;
    lnot(a: number): number;
    neg(a: number): number;
    eq(a: number, b: number): number;
    ne(a: number, b: number): number;
    lt(a: number, b: number): number;
    gt(a: number, b: number): number;
    le(a: number, b: number): number;
    ge(a: number, b: number): number;
    min(a: number, b: number): number;
    max(a: number, b: number): number;
    ABS(arg: number): number;
    ASC(arg: string): number;
    ATN(arg: number): number;
    CHR$(arg: number): string;
    CINT(arg: number): number;
    COS(arg: number): number;
    COT(arg: number): number;
    CTL(arg: number): string;
    EXP(arg: number): number;
    FIX(arg: number): number;
    HEX$(arg: number): string;
    INSTR(a: any, b: any, c: any): number;
    INT(arg: number): number;
    LEFT$(arg: string, count: number): string;
    LEN(arg: string): number;
    LIN(arg: number): string;
    LOG(arg: number): number;
    LOG10(arg: number): number;
    MID$(arg: string, start: number, count: number): string;
    OCT$(arg: number): string;
    PI(): number;
    POS(arg1: any, arg2: any): number | boolean;
    RIGHT$(arg: string, count: number): string;
    RND(arg: number): number;
    ROUND(arg: number): number;
    SGN(arg: number): number;
    SIN(arg: number): number;
    SPACE$(arg: number): string;
    SPC(arg: number): string;
    SQR(arg: number): number;
    STR$(arg: number): string;
    STRING$(len: number, chr: number | string): string;
    TAB(arg: number): string;
    TAN(arg: number): number;
    TIM(arg: number): number;
    TIMER(): number;
    UPS$(arg: string): string;
    VAL(arg: string): number;
    LPAD$(arg: string, len: number): string;
    RPAD$(arg: string, len: number): string;
    NFORMAT$(arg: number, numlen: number): string;
}
export {};
